@Library('jenkins-shared-libs') _

// Set by default that release meets the requirements
def releaseReqMeet = true
// Set by default that it's not a conditional release
def conditionalRelease = false

pipeline {
    agent {
        label 'azure-docker'
    }
    options {
        buildDiscarder(
            logRotator(numToKeepStr: '5')
        )
        timestamps()
        disableConcurrentBuilds()
        timeout(
            time: 1,
            unit: 'HOURS'
        )
        durabilityHint('PERFORMANCE_OPTIMIZED')
        ansiColor('xterm')
        skipDefaultCheckout()
    }
    environment {
        PATH = "$PATH:$HOME/.local/bin"
        APP_NAME = 'flask-api-pizzaapp'
        TARGET_ENV = 'uat-env'
        AZURE_SP = credentials('azure-aks-testcluster-service-principal')
        AZURE_REGISTRY_USR = '00000000-0000-0000-0000-000000000000'
    }
    stages {
        stage('Prepare variables') {
            steps {
                script {
                    env.GIT_BRANCH = scm.branches[0].name
                    env.GIT_URL = scm.userRemoteConfigs[0].url
                    dbCredentialsId = 'flask-api-pizzaapp-database-uat-env'
                    echo "Git repo url: ${env.GIT_URL}"
                    echo "Git branch: ${env.GIT_BRANCH}"
                    if (
                        currentBuild.getBuildCauses().toString().contains('BranchIndexingCause') || 
                        currentBuild.getBuildCauses().toString().contains('Branch event')
                    ) {
                        currentBuild.result = 'ABORTED'
                        error('Build aborted because of an external trigger!')
                    }
                    if (!(env.GIT_BRANCH == 'development')) {
                        error('You can use this pipeline only from development branch!')
                    }
                    exposeVariablesFromConfigFile(configFileProviderFileId: 'azure-config')
                    echo 'Exposing other variables...'
                    env.INGRESS_HOST = "${env.APP_NAME}-${env.TARGET_ENV}.${env.AZURE_INGRESS_DOMAIN}"
                    sh '''
                    az login --service-principal \
                    --username $AZURE_SP_USR \
                    --password $AZURE_SP_PSW \
                    --tenant $AZURE_TENANT
                    '''
                }
            }
        }
        stage('Select image to release') {
            steps {
                script {
                    def imageTags = sh(
                        returnStdout: true,
                        script: '''
                        az acr repository show-tags --name ${AZURE_REGISTRY_ADDRESS} \
                        --repository ${APP_NAME} --orderby time_desc --output tsv | \
                        grep '^development-[0-9]\\+$'
                        '''
                    ).trim()
                    timeout(time: 5, unit: 'MINUTES') {
                        env.SELECTED_TAG = input(
                            message: 'Select image to create release',
                            parameters: [
                                choice(
                                    name: 'Image tag to be used to create release',
                                    choices: imageTags,
                                    description: 'Select image that will be used to create release version.' +
                                    '\nOnly builds from development branch are allowed'
                                )
                            ]
                        )
                    }
                    echo "Image tag selected to create release: ${env.SELECTED_TAG}"
                    sh '''
                     az acr login --name $AZURE_REGISTRY_ADDRESS --expose-token \
                    --output tsv --query accessToken | \
                    docker login $AZURE_REGISTRY_ADDRESS --username $AZURE_REGISTRY_USR --password-stdin
                    docker pull ${AZURE_REGISTRY_ADDRESS}/${APP_NAME}:${SELECTED_TAG}
                    '''
                }
            }
        }
        stage('Create new tag') {
            steps {
                script {
                    env.IMAGE_COMMIT_ID = sh(
                        returnStdout: true,
                        script: '''
                        docker inspect --format '{{ index .Config.Labels "COMMIT_ID" }}' \
                        ${AZURE_REGISTRY_ADDRESS}/${APP_NAME}:${SELECTED_TAG}
                        '''
                    ).trim()
                    def labelsMap = [
                        "LEAKED_SECRETS_CHECK": null,
                        "DEPENDENCY_SECURITY_CHECK": null,
                        "SONAR_QG_STATUS": null,
                    ]
                    // Check if each image tag value equals "OK"
                    for (i in labelsMap) {
                        echo "Verify if image meets the condition ${i.key}..."
                        conditionResult = sh(
                            returnStdout: true,
                            script: """
                            docker inspect --format "{{ index .Config.Labels "'"${i.key}"'" }}" \
                            ${AZURE_REGISTRY_ADDRESS}/${APP_NAME}:${SELECTED_TAG}
                            """
                        ).trim()
                        if (conditionResult == 'OK') {
                            echo "--> ${i.key} PASSED!"
                            releaseReqMeet = true
                        } else {
                            echo "Condition ${i.key} is not meet: ${conditionResult}"
                            // Conditional acceptance of release required
                            // because one of conditions is not meet
                            releaseReqMeet = false
                            conditionalRelease = true
                        }
                        // Update map entry
                        labelsMap."${i.key}" = "${conditionResult}"
                    }
                    if (conditionalRelease) {
                        operatorInput = input(
                            message: 'Release conditions issue',
                            parameters: [
                                booleanParam(
                                    name: 'conditionalAcceptance',
                                    defaultValue: false,
                                    description: 'One or more of release conditions are not meet.\n\n' +
                                    "${tagMap}\n\n" +
                                    'Do you want to proceed with conditional release?'
                                )
                            ],
                            submitterParameter: 'acceptedBy'
                        )
                        releaseReqMeet = operatorInput.conditionalAcceptance
                        // Expose as env variable for better integration with shell
                        env.ACCEPTED_BY = operatorInput.acceptedBy
                    }
                    if (!releaseReqMeet) {
                        error('Release requirements are not meet, aborting release!')
                    } else if (conditionalRelease && releaseReqMeet) {
                        unstable('Not all release conditions are meet; proceding with conditional release; ' +
                        "accepted by ${env.ACCEPTED_BY}; marking build as unstable!")
                    } else {
                        echo "All conditions are meet!"
                    }
                    echo "Following commit will be selected to create tag: ${env.IMAGE_COMMIT_ID}"
                    // Perform checkout including tags
                    checkout([
                        $class: 'GitSCM',
                        branches: [
                            [name: env.GIT_BRANCH]
                        ],
                        extensions: [
                            [
                                $class: 'CloneOption',
                                honorRefspec: true,
                                noTags: false,
                                shallow: false
                            ]
                        ],
                        userRemoteConfigs: [
                            [
                                credentialsId: scm.userRemoteConfigs[0].credentialsId,
                                url: env.GIT_URL
                            ]
                        ]
                    ])
                    def gitRepoTags = sh(
                        returnStdout: true,
                        script: 'git tag --sort=-v:refname'
                    ).split()
                    if (!gitRepoTags) {
                        echo "No tags found in repo ${env.GIT_URL} in branch ${env.GIT_BRANCH}"
                        nextMajorVersion = '1.0.0'
                        nextMinorVersion = 'N/A'
                        nextPatchVersion = 'N/A'
                        echo "Creating automatically initial version: ${nextMajorVersion}"
                    } else {
                        echo "Following tags were found in repo ${env.GIT_URL} in branch ${env.GIT_BRANCH}:"
                        echo "${gitRepoTags}"
                        def lastVersion = gitRepoTags.first()
                        echo "Last version: ${lastVersion}"
                        def (major, minor, patch) = lastVersion.tokenize('.').collect { it.toInteger() }
                        nextMajorVersion = "${major + 1}.0.0"
                        nextMinorVersion = "${major}.${minor + 1}.0"
                        nextPatchVersion = "${major}.${minor}.${patch + 1}"
                    }
                    timeout(time: 5, unit: 'MINUTES') {
                        env.NEW_RELEASE_TAG = input(
                            message: 'Provide new tag to be created',
                            parameters: [
                                string(
                                    name: 'New tag to be created',
                                    defaultValue: 'Put version here',
                                    description: 'Possible versions:\n\n' +
                                    "Major: ${nextMajorVersion}\n" +
                                    "Minor: ${nextMinorVersion}\n" +
                                    "Patch: ${nextPatchVersion}",
                                    trim: true
                                )
                            ]
                        )
                    }
                    if (!(env.NEW_RELEASE_TAG =~ '[0-9]+\\.[0-9]+\\.[0-9]+')) {
                        error('Invalid tag, it should have format X.X.X!')
                    }
                    if (gitRepoTags.contains(env.NEW_RELEASE_TAG)) {
                        error("Tag ${env.NEW_RELEASE_TAG} already exists!")
                    }
                    echo 'Creating git tag...'
                    sh '''
                    git config --global user.email "jenkins-bot@thinkbox.pl"
                    git config --global user.name "Jenkins Bot"
                    git tag -a ${NEW_RELEASE_TAG} ${IMAGE_COMMIT_ID} -m "Version ${NEW_RELEASE_TAG}"
                    '''
                    echo 'Tagging docker image...'
                    if (conditionalRelease && releaseReqMeet) {
                        // Took from SO: https://stackoverflow.com/a/54598281
                        echo 'Rebuilding image to add new labels because of conditional release'
                        sh '''
                        echo "FROM ${AZURE_REGISTRY_ADDRESS}/${APP_NAME}:${SELECTED_TAG}" | \
                        docker build --label CONDITIONAL_RELEASE="true" \
                        --label CONDITIONAL_REL_ACCEPTED_BY=${ACCEPTED_BY} \
                        -t "${AZURE_REGISTRY_ADDRESS}/${APP_NAME}:${NEW_RELEASE_TAG}" -
                        '''
                    } else {
                        sh '''
                        docker tag ${AZURE_REGISTRY_ADDRESS}/${APP_NAME}:${SELECTED_TAG} \
                        ${AZURE_REGISTRY_ADDRESS}/${APP_NAME}:${NEW_RELEASE_TAG}
                        '''
                    }
                }
            }
        }
        stage('Promote image') {
            steps {
                script {
                    withCredentials([
                        usernamePassword(
                            credentialsId: scm.userRemoteConfigs[0].credentialsId,
                            passwordVariable: 'GIT_PASSWORD',
                            usernameVariable: 'GIT_USERNAME'
                        )
                    ]) {
                        try {
                            echo 'Pushing git tag to repository...'
                            sh 'git push https://${GIT_USERNAME}:${GIT_PASSWORD}@${GIT_URL#https://} --tags'
                            echo 'Pushing tagged image to registry...'
                            sh 'docker push ${AZURE_REGISTRY_ADDRESS}/${APP_NAME}:${NEW_RELEASE_TAG}'
                        } catch(err) {
                            echo "Following error occured: ${err}"
                            echo 'Reverting changes...'
                            sh 'az acr repository delete --yes --name ${AZURE_REGISTRY_ADDRESS} --image ${APP_NAME}:${NEW_RELEASE_TAG} || true'
                            sh 'git push --delete https://${GIT_USERNAME}:${GIT_PASSWORD}@${GIT_URL#https://} ${NEW_RELEASE_TAG} || true'
                            error('Failed to promote image!')
                        }
                    }
                }
            }
        }
        stage('Deploy to target environment') {
            steps {
                script {
                    echo "Checking out to following tag: ${env.NEW_RELEASE_TAG}"
                    checkout([
                        $class: 'GitSCM',
                        branches: [
                            [name: env.NEW_RELEASE_TAG]
                        ],
                        extensions: [
                            [
                                $class: 'CloneOption',
                                honorRefspec: true,
                                noTags: false,
                                shallow: false
                            ]
                        ],
                        userRemoteConfigs: [
                            [
                                credentialsId: scm.userRemoteConfigs[0].credentialsId,
                                url: env.GIT_URL
                            ]
                        ]
                    ])
                    echo "Deploying to ${env.TARGET_ENV}"
                    withCredentials([
                        usernamePassword(
                            credentialsId: dbCredentialsId,
                            passwordVariable: 'DATABASE_CRED_PSW',
                            usernameVariable: 'DATABASE_CRED_USR'
                        )
                    ]) {
                        sh '''
                        az aks get-credentials --resource-group $AZURE_RESOURCE_GROUP_NAME \
                        --name $AZURE_KUBE_CLUSTER_NAME --admin
                        helm upgrade --install $APP_NAME ./helm/$APP_NAME \
                        --wait \
                        --timeout 10m \
                        --atomic \
                        --namespace "$TARGET_ENV" \
                        --values ./helm/environments/${TARGET_ENV}.yaml \
                        --set image.repository="${AZURE_REGISTRY_ADDRESS}/${APP_NAME}" \
                        --set image.tag="${NEW_RELEASE_TAG}" \
                        --set ingress.host="${INGRESS_HOST}" \
                        --set env.secrets.FLASK_DB_USER="${DATABASE_CRED_USR}" \
                        --set env.secrets.FLASK_DB_PASS="${DATABASE_CRED_PSW}"
                        '''
                    }
                }
            }
        }
    }
    post {
        cleanup {
            cleanWs()
        }
    }
}

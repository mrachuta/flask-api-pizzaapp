def leakedSecretsCheck = 'UNKNOWN'
def dependencySecurityCheck = 'UNKNOWN'
def sonarQGStatus = 'UNKNOWN'

pipeline {
    agent {
        label 'azure-docker'
    }
    options {
        buildDiscarder(
            logRotator(numToKeepStr: '5')
        )
        timestamps()
        disableConcurrentBuilds()
        timeout(
            time: 1,
            unit: 'HOURS'
        )
        durabilityHint('PERFORMANCE_OPTIMIZED')
        ansiColor('xterm')
    }
    environment {
        PATH = "$PATH:$HOME/.local/bin"
        APP_NAME = 'flask-api-pizzaapp'
        TAG_NAME = "${env.GIT_BRANCH.replaceAll('/', '-').take(23)}-${env.BUILD_NUMBER}"
        TARGET_ENV = 'dev-env'
        AZURE_SP = credentials('azure-aks-testcluster-service-principal')
        AZURE_REGISTRY_USR = '00000000-0000-0000-0000-000000000000'
        TECHNICAL_ACCOUNT = credentials('technical-account-ldap')
        PRIVATE_REGISTRY_ADDRESS = 'nexus3.k8s.lan:50000'
    }
    parameters {
        booleanParam(
            name: 'RUN_LEAKED_SECRETS_CHECK',
            defaultValue: true,
            description: 'Do you want to run checks again leaked secrets in your branch?'
        )
        booleanParam(
            name: 'RUN_LINTER',
            defaultValue: true,
            description: 'Do you want to perform pylint evaluation?'
        )
        booleanParam(
            name: 'RUN_UNIT_TESTS',
            defaultValue: true,
            description: 'Do you want to run unit test stage?'
        )
        booleanParam(
            name: 'RUN_DEPENDENCY_SECURITY_CHECK',
            defaultValue: true,
            description: 'Do you want to run security checks on python dependencies?'
        )
        booleanParam(
            name: 'RUN_SONARQUBE',
            defaultValue: true,
            description: 'Do you want to perform SCA using Sonarqube analysis?'
        )
        booleanParam(
            name: 'RUN_CHECKOV',
            defaultValue: true,
            description: 'Do you want to perform SCA using checkov on Docker, k8s and helm resources?'
        )
        booleanParam(
            name: 'CREATE_IMAGE',
            defaultValue: false,
            description: 'Do you want to create and push image to registy?'
        )
        booleanParam(
            name: 'DEPLOY_TO_ENV',
            defaultValue: false,
            description: 'Do you want to deploy image to target environment?'
        )
    }
    stages {
        stage('Prepare variables') {
            steps {
                script {
                    dbCredentialsId = 'flask-api-pizzaapp-database-dev-env'
                    echo "Git repo url: ${env.GIT_URL}"
                    echo "Git branch: ${env.GIT_BRANCH}"
                    echo 'Exposing Azure-specific env variables...'
                    configFileProvider([
                        configFile(
                            fileId: 'azure-config',
                            variable: 'AZURE_CONFIGURATION'
                        )
                    ]) {
                        // Split by each line, then split by '=' and remove quotes
                        azureVariables = readFile("${env.AZURE_CONFIGURATION}").split('\n').collect { azVar ->
                            azVar.split('=').last().replaceAll("^\"|^\'|\'\$|\"\$", "")
                        }
                        env.AZURE_SUBSCRIPTION_ID = azureVariables[0]
                        env.AZURE_TENANT = azureVariables[1]
                        env.AZURE_TENANT_ID = azureVariables[2]
                        env.AZURE_KUBE_CLUSTER_NAME = azureVariables[3]
                        env.AZURE_REGISTRY_ADDRESS = azureVariables[4]
                        env.AZURE_RESOURCE_GROUP_NAME = azureVariables[5]
                        env.AZURE_INGRESS_DOMAIN = azureVariables[6]
                        env.AZURE_RESOURCES_RG_NAME = azureVariables[7]
                        env.AZURE_STORAGE_ACCOUNT_NAME = azureVariables[8]
                        env.OVH_ZONE = azureVariables[9]
                    }
                    echo 'Exposing rest of variables...'
                    env.INGRESS_HOST = "${env.APP_NAME}-${env.TARGET_ENV}.${env.AZURE_INGRESS_DOMAIN}"
                    sh '''
                    az login --service-principal \
                    --username $AZURE_SP_USR \
                    --password $AZURE_SP_PSW \
                    --tenant $AZURE_TENANT
                    '''
                }
            }
        }
        stage('Install packages') {
            steps {
                sh 'pip install -r requirements.txt'
            }
        }
        stage('Run leaked-secrets check') {
            when { expression { params.RUN_LEAKED_SECRETS_CHECK } }
            steps {
                script {
                    def trufflehogHome = tool('trufflehog_default')
                    withEnv(["PATH+EXTRA=${trufflehogHome}"]) {
                        try {
                            sh 'trufflehog git ${GIT_URL} --branch ${GIT_BRANCH}'
                            leakedSecretsCheck = 'OK'
                            // No explicit information from tool
                            echo 'Leaked-secrets check passed!'
                        } catch(Exception e) {
                            leakedSecretsCheck = 'NOK'
                            error('Leaked-secrets check failed!')
                        }
                    }
                }
            }
        }
        stage('Run linter') {
            when { expression { params.RUN_LINTER } }
            steps {
                sh 'find . -name \\*.py | xargs pylint -f parseable | tee pylint.log'
                recordIssues(
                    tool: pyLint(pattern: 'pylint.log')
                )
            }
        }
        stage('Run unit tests') {
            when { expression { params.RUN_UNIT_TESTS } }
            steps {
                sh '''
                pytest --cov=pizzaapp \
                --cov-report xml:coverage-reports/pycov/report.xml \
                --junitxml pytest-results.xml 
                '''
                publishCoverage(
                    adapters: [
                        coberturaAdapter(
                            path: 'coverage-reports/pycov/report.xml',
                        )
                    ]
                )
                junit(
                    allowEmptyResults: true,
                    skipMarkingBuildUnstable: true,
                    skipPublishingChecks: true,
                    testResults: 'pytest-results.xml'
                )
            }
        }
        stage('Run security checks on dependencies') {
            when { expression { params.RUN_DEPENDENCY_SECURITY_CHECK } }
            steps {
                script {
                    try {
                        sh '''
                        pip3 install safety
                        safety check -r requirements.txt
                        '''
                        dependencySecurityCheck = 'OK'
                    } catch(Exception e) {
                        dependencySecurityCheck = 'NOK'
                        unstable('Security checks on dependencies failed!')
                    }
                    //TODO: save output as junit-like xml https://github.com/pyupio/safety/pull/190
                }
            }
        }
        // TODO: add liccheck https://pypi.org/project/liccheck/
        stage('Run Sonarqube analysis') {
            when { expression { params.RUN_SONARQUBE } }
            steps {
                script {
                    def scannerHome = tool('sonarqube_scanner_default')
                    def nodeHome = tool('nodejs_default')
                    withEnv(["PATH+EXTRA=${scannerHome}/bin:${nodeHome}/bin"]) {
                        withSonarQubeEnv('sonarqube_default') {
                            sh('sonar-scanner')
                        }
                        timeout(time: 10, unit: 'MINUTES') {
                            def qg = waitForQualityGate()
                            if (qg.status != 'OK') {
                                unstable("Marking build as unstable due to quality gate failure: ${qg.status})")
                                sonarQGStatus = 'NOK'
                            } else {
                                sonarQGStatus = qg.status
                            }
                        }
                    }
                }
            }
        }
        stage('Run checkov on other resources') {
            when { expression { params.RUN_CHECKOV } }
            steps {
                sh 'pip3 install checkov'
                sh 'checkov --config-file ./checkov-docker.yml'
                sh 'checkov --config-file ./checkov-helm.yml'
                junit(
                    allowEmptyResults: true,
                    skipMarkingBuildUnstable: true,
                    skipPublishingChecks: true,
                    testResults: 'checkov-results*.xml'
                )
            }
        }
        stage('Create Docker image') {
            when { expression { params.CREATE_IMAGE } }
            steps {
                script {
                    if (!params.RUN_LEAKED_SECRETS_CHECK || !params.RUN_LINTER || !params.RUN_UNIT_TESTS) {
                        error(
                            'You canot create image without passing at least: linter, ' +
                            'unit tests and leaked-secrets stages!'
                        )
                    }
                    echo "Building image with tag: ${env.TAG_NAME}"
                    sh '''
                    echo "$TECHNICAL_ACCOUNT_PSW" | \
                    docker login $PRIVATE_REGISTRY_ADDRESS --username $TECHNICAL_ACCOUNT_USR --password-stdin
                    '''
                    sh """
                    docker build . --pull --network host \
                    --tag ${env.APP_NAME}:${env.TAG_NAME} \
                    --label COMMIT_ID=${env.GIT_COMMIT} \
                    --label BRANCH=${env.GIT_BRANCH} \
                    --label BUILD_NO=${env.BUILD_NUMBER} \
                    --label LEAKED_SECRETS_CHECK=${leakedSecretsCheck} \
                    --label DEPENDENCY_SECURITY_CHECK=${dependencySecurityCheck} \
                    --label SONAR_QG_STATUS=${sonarQGStatus}
                    """
                    sh '''
                    az acr login --name $AZURE_REGISTRY_ADDRESS --expose-token \
                    --output tsv --query accessToken | \
                    docker login $AZURE_REGISTRY_ADDRESS --username $AZURE_REGISTRY_USR --password-stdin
                    docker tag ${APP_NAME}:${TAG_NAME} ${AZURE_REGISTRY_ADDRESS}/${APP_NAME}:${TAG_NAME}
                    docker push ${AZURE_REGISTRY_ADDRESS}/${APP_NAME}:${TAG_NAME}
                    '''
                }
            }
        }
        // TODO: Implement Clair as Static Analysis for container image
        stage('Deploy to target environment') {
            when { expression { params.DEPLOY_TO_ENV } }
            steps {
                script {
                    if (!params.RUN_LEAKED_SECRETS_CHECK || !params.RUN_LINTER || !params.RUN_UNIT_TESTS || !params.CREATE_IMAGE) {
                        error(
                            'You canot create image without passing at least: linter, unit tests, ' +
                            'leaked-secrets check and create docker image stages!'
                        )
                    }
                    echo "Deploying to ${env.TARGET_ENV}"
                    withCredentials([
                        usernamePassword(
                            credentialsId: dbCredentialsId,
                            passwordVariable: 'DATABASE_CRED_PSW',
                            usernameVariable: 'DATABASE_CRED_USR'
                        )
                    ]) {
                        sh '''
                        az aks get-credentials --resource-group $AZURE_RESOURCE_GROUP_NAME \
                        --name $AZURE_KUBE_CLUSTER_NAME --admin
                        helm upgrade --install $APP_NAME ./helm/$APP_NAME \
                        --wait \
                        --timeout 10m \
                        --atomic \
                        --namespace "$TARGET_ENV" \
                        --values ./helm/environments/${TARGET_ENV}.yaml \
                        --set image.repository="${AZURE_REGISTRY_ADDRESS}/${APP_NAME}" \
                        --set image.tag="${TAG_NAME}" \
                        --set ingress.host="${INGRESS_HOST}" \
                        --set env.secrets.FLASK_DB_USER="${DATABASE_CRED_USR}" \
                        --set env.secrets.FLASK_DB_PASS="${DATABASE_CRED_PSW}"
                        '''
                    }
                }
            }
        }
    }
    post {
        success {
            script {
                sh '''
                az login --service-principal \
                --username $AZURE_SP_USR \
                --password $AZURE_SP_PSW \
                --tenant $AZURE_TENANT
                '''
                // Get all images, sort out release versions (reverse grep)
                obsoleteImageList = sh(
                    returnStdout: true,
                    script: '''
                    az acr manifest metadata list --registry $AZURE_REGISTRY_ADDRESS \
                    --name $APP_NAME --orderby time_asc \
                    --query "[?lastUpdateTime < '$(date --date='-30 days' '+%Y-%m-%d')'].tags[]" -o tsv |\
                    grep -v '[0-9]\\+.[0-9]\\+.[0-9]\\+' || true
                    '''
                ).split()
                if (obsoleteImageList) {
                    obsoleteImageList.each { imageTag ->
                        echo "Deleting ${imageTag} -> older than 30 days!"
                        sh """
                        az acr repository delete --yes --name ${env.AZURE_REGISTRY_ADDRESS} \
                        --image ${env.APP_NAME}:${imageTag}
                        """
                    }
                } else {
                    echo 'No images older than 30 days'
                }
            }
        }
        cleanup {
            cleanWs()
        }
    }
}
